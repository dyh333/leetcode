### 思路
记 rev 为翻转后的数字，为完成翻转，我们可以重复「弹出」x 的末尾数字，将其「推入」rev 的末尾，直至 x 为 0。

在没有辅助栈或数组的帮助下「弹出」和「推入」数字，可以使用如下方法：
```
// 弹出 x 的末尾数字 digit
digit = x % 10
x /= 10

// 将数字 digit 推入 rev 末尾
rev = rev * 10 + digit
```

### 代码
```js
var reverse = function (x) {
  const isNegative = x < 0;
  x = Math.abs(x);
  let rev = 0;

  while (x) {
    rev = rev * 10 + (x % 10);
    x = Math.floor(x / 10);
  }

  if (rev > Math.pow(2, 31) - 1) {
    return 0;
  }

  if (isNegative) {
    rev = -rev;
  }

  return rev;
};
```

### 注意
上面的代码虽然能被AC，但是有几处地方值得讨论：
1. 是否超过最大值的判断放在了循环体的外层是不太合适的，因为可能在循环体内赋值 rev 的时候就已经溢出了；
2. 负数先取绝对值最后再取负：这是因为使用了 Math.floor 函数，如果 x 是负数如 -123 ，向下取整后的值和我们预期的就会不一样：
```
Math.floor(123 / 10) // 12
Math.floor(-123 / 10) // -13
```
这里也可以使用 ~~ 来替代 Math.floor 函数，它表示按位补码两次，即将值转换为整数：
```
~~5.5    // 5
~~(-5.5) // -5
```
但是个人认为代码可读性会稍微差一些，因此仍保留绝对值处理。

### 代码
```js
var reverse = function (x) {
  const isNegative = x < 0;
  const max = Math.pow(2, 31) - 1;
  let tooBig = false;
  x = Math.abs(x);
  let rev = 0;

  while (x) {
    rev = rev * 10 + (x % 10);
    x = Math.floor(x / 10);

    if (rev > max) {
      tooBig = true;
      break;
    }
  }

  if (tooBig) {
    return 0;
  } else {
    return isNegative ? -rev : rev;
  }
};
```


### 复杂度分析

* 时间复杂度：O(log∣x∣)。翻转的次数即 x 十进制的位数。
* 空间复杂度：O(1)。