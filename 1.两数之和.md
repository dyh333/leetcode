## 方法一：暴力枚举
### 思路
通过两层循环枚举数组中的每一个数 x 和 y ，寻找 x + y === target。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。所以我们只需要在 x 后面的元素中寻找 target - x。

### 代码
```js
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
};
```

### 复杂度分析

* 时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
* 空间复杂度：O(1)。



## 方法二：哈希表
### 思路
注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。对于每一个 x，我们首先查询哈希表中是否存在 target - x，不存在则将 x 插入到哈希表中，等待与下一个 x 匹配。

在javascript中可以使用Map数据结构来模拟hash存储。

### 代码
```js
var twoSum = function (nums, target) {
  let map = new Map();

  for (let i = 0; i < nums.length; i++) {
    const diff = target - nums[i];
    if (map.has(diff)) {
      return [map.get(diff), i];
    } else {
      map.set(nums[i], i);
    }
  }
};
```

### 复杂度分析
* 时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。
* 空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。