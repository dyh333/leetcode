### 思路
通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。

例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。

若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。

例如 XIV 可视作 X−I+V=10−1+5=14。

### 代码
```js
var romanToInt = function (s) {
  const map = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000
  };

  let result = 0;

  for (let i = 0; i < s.length; i++) {
    const cur = map[s[i]];
    const next = map[s[i + 1]];

    if (cur < next) {
      result -= cur;
    } else {
      // cur >= next
      result += cur;
    }
  }

  return result;
};
```

### 注意
for循环的结束条件是 i < s.length ，当i = s.length - 1 时，next = undefined ，此时 cur < undefined 必然不成立，所以将掉入else条件中，即加上最后一位数。

因此不需单独处理最后一位。

### 复杂度分析
时间复杂度：O(n)，其中 n 是字符串 s 的长度。

空间复杂度：O(1)。