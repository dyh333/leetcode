### 思路
首先处理一些临界情况：
1. 所有负数都不可能是回文，可以对所有负数返回 false；
2. 除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。可以对所有大于 0 且个位是 0 的数字返回 false

### 代码
```js
var isPalindrome = function (x) {
  if (x < 0 || (x > 0 && x % 10 === 0)) {
    return false;
  }

  let rev = 0;
  let ori = x;

  while (x) {
    rev = rev * 10 + (x % 10);
    x = Math.floor(x / 10);
  }

  return ori === rev;
};
```

### 注意
上面的代码虽然能被AC，但是有几处地方值得讨论：
1. 如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题；
2. 为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

如何知道反转数字的位数已经达到原始数字位数的一半？由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

最后在判断是否回文时，当数字长度为奇数时，处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地通过 revertedNumber/10 将其去除。

### 代码
```js
var isPalindrome = function (x) {
  if (x < 0 || (x > 0 && x % 10 === 0)) {
    return false;
  }

  let rev = 0;

  while (rev < x) {
    rev = rev * 10 + (x % 10);
    x = Math.floor(x / 10);
  }

  return x === rev || x === Math.floor(rev / 10);
};
```


### 复杂度分析
时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 1010，因此时间复杂度为 O(logn)。
空间复杂度：O(1)。我们只需要常数空间存放若干变量。